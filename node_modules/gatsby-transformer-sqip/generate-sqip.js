"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _require = require("path"),
    resolve = _require.resolve,
    parse = _require.parse;

var Debug = require("debug");

var _require2 = require("fs-extra"),
    exists = _require2.exists,
    readFile = _require2.readFile,
    writeFile = _require2.writeFile;

var svgToMiniDataURI = require("mini-svg-data-uri");

var PQueue = require("p-queue");

var sqip = require("sqip");

var _require3 = require("gatsby-core-utils"),
    createContentDigest = _require3.createContentDigest;

var queue = new PQueue({
  concurrency: 1
});
var debug = Debug("gatsby-transformer-sqip");

module.exports = function generateSqip(options) {
  var cache, absolutePath, numberOfPrimitives, blur, mode, cacheDir, contentDigest, _parse, name, ext, sqipOptions, optionsHash, cacheKey, cachePath;

  return _regenerator.default.async(function generateSqip$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          cache = options.cache, absolutePath = options.absolutePath, numberOfPrimitives = options.numberOfPrimitives, blur = options.blur, mode = options.mode, cacheDir = options.cacheDir, contentDigest = options.contentDigest;
          debug({
            options: options
          });
          _parse = parse(absolutePath), name = _parse.name, ext = _parse.ext;

          if (ext.match(/(jpe?g|png|gif)$/)) {
            _context2.next = 6;
            break;
          }

          debug("Unsupported file type " + name + " (" + contentDigest + ")");
          return _context2.abrupt("return", null);

        case 6:
          sqipOptions = {
            numberOfPrimitives: numberOfPrimitives,
            blur: blur,
            mode: mode
          };
          optionsHash = createContentDigest(sqipOptions);
          cacheKey = contentDigest + "-" + optionsHash;
          cachePath = resolve(cacheDir, contentDigest + "-" + optionsHash + ".svg");
          debug("Request preview generation for " + name + " (" + contentDigest + "-" + optionsHash + ")");
          return _context2.abrupt("return", queue.add(function _callee() {
            var primitiveData, svg, svgBuffer, result;
            return _regenerator.default.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _regenerator.default.awrap(cache.get(cacheKey));

                  case 2:
                    primitiveData = _context.sent;

                    if (primitiveData) {
                      _context.next = 33;
                      break;
                    }

                    debug("Executing preview generation request for " + name + " (" + contentDigest + "-" + optionsHash + ")");
                    _context.prev = 5;
                    _context.next = 8;
                    return _regenerator.default.awrap(exists(cachePath));

                  case 8:
                    if (!_context.sent) {
                      _context.next = 16;
                      break;
                    }

                    debug("Primitive result file already exists for " + name + " (" + contentDigest + "-" + optionsHash + ")");
                    _context.next = 12;
                    return _regenerator.default.awrap(readFile(cachePath));

                  case 12:
                    svgBuffer = _context.sent;
                    svg = svgBuffer.toString();
                    _context.next = 24;
                    break;

                  case 16:
                    debug("Generate primitive result file of " + name + " (" + contentDigest + "-" + optionsHash + ")");
                    _context.next = 19;
                    return _regenerator.default.awrap(new Promise(function (resolve, reject) {
                      try {
                        var _result = sqip((0, _extends2.default)({
                          filename: absolutePath
                        }, sqipOptions));

                        resolve(_result);
                      } catch (error) {
                        reject(error);
                      }
                    }));

                  case 19:
                    result = _context.sent;
                    svg = result.final_svg;
                    _context.next = 23;
                    return _regenerator.default.awrap(writeFile(cachePath, svg));

                  case 23:
                    debug("Wrote primitive result file to disk for " + name + " (" + contentDigest + "-" + optionsHash + ")");

                  case 24:
                    primitiveData = {
                      svg: svg,
                      dataURI: svgToMiniDataURI(svg)
                    };
                    _context.next = 27;
                    return _regenerator.default.awrap(cache.set(cacheKey, primitiveData));

                  case 27:
                    _context.next = 33;
                    break;

                  case 29:
                    _context.prev = 29;
                    _context.t0 = _context["catch"](5);
                    _context.t0.message = "Unable to generate SQIP for " + name + " (" + contentDigest + "-" + optionsHash + ")\n" + _context.t0.message;
                    throw _context.t0;

                  case 33:
                    return _context.abrupt("return", primitiveData);

                  case 34:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, null, [[5, 29]]);
          }));

        case 12:
        case "end":
          return _context2.stop();
      }
    }
  });
};